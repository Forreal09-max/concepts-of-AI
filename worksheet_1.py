# -*- coding: utf-8 -*-
"""Worksheet-1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1RAA8tHWA8udZBGvdraN4c37aMEp28Vbo
"""

#ARRAY CREATION
#1. Initialize an empty array with size 2X2.
import numpy as np
arr_zero = np.zeros((2,2))
print(arr_zero)



#2. Initialize an all one array with size 4X2.
arr_one = np.ones((4,2))
print(arr_one)

#3. Return a new array of given shape and type, filled with
#fill value.{Hint: np.full}
arr_full = np.full((4,2),5)
print(arr_full)



#4. Return a new array of zeros with same shape and type as a
#given array.{Hint: np.zeros like}
arr = np.full((2,4),4)
print(arr)
arr_zero = np.zeros_like(arr)
print(arr_zero)

# 5. Return a new array of ones with same shape
# and type as a given array.{Hint: np.ones like}

arr = np.full((4,3),8)
print(arr)
arr_ones = np.ones_like(arr)
print(arr_ones)

# 6. For an existing list new_list = [1,2,3,4] convert to an
#numpy array.{Hint: np.array()}

new_list = [1,2,3,4]
arr = np.array(new_list)
print(arr)

#ARRAY MANIPULATION
#1. Create an array with values
# ranging from 10 to 49. {Hint:np.arrange()}.
arr = np.arange(10,50)
print(arr)

# 2. Create a 3X3 matrix with values ranging from 0 to 8.
#{Hint:look for np.reshape()}
arr = np.arange(0,9)
arr1 = arr.reshape(3,3)
print(arr1)

#3 Create a 3X3 identity matrix.{Hint:np.eye()}
arr = np.eye(3)
print(arr)

#4 Create a random array of size 30 and find the mean of the array.
arr = np.random.random(30)
print(arr.mean())

# 5. Create a 10X10 array with random values and find the
#minimum and maximum values.
import numpy as np
arr = np.random.random((10,10))
print(arr.max())
print(arr.min())

# 6. Create a zero array of size 10 and replace 5th element with 1.
arr = np.zeros(10)
arr[4] = 1
print(arr)

#7. Reverse an array arr = [1,2,0,0,4,0].
arr =  [1,2,0,0,4,0]
reversedArr = arr[::-1]
print(reversedArr)

#8. Create a 2d array with 1 on border and 0 inside.
arr = np.ones((5,5))
arr[1:-1,1:-1] = 0
print(arr)

#9. Create a 8X8 matrix and fill it with a checkerboard pattern.
import numpy as np

arr = np.zeros((8, 8), dtype=int)
arr[1::2, ::2] = 1
arr[::2, 1::2] = 1

print(arr) 

#ARRAY OPERATIONS
#For the following arrays:
#x = np.array([[1,2],[3,5]]) and y = np.array([[5,6],[7,8]]);
#v = np.array([9,10]) and w = np.array([11,12]);

#1. Add the two array.
x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
print(x+y)

#2. Subtract the two array.
v = np.array([9,10])
w = np.array([11,12])
print(w-v)

#3. Multiply the array with any integers of your choice.
w = np.array([11,12])
print(w*2)

#Find the square of each element of the array.
import math
v = np.array([9,10])
print(v**2)

#5. Find the dot product between: v(and)w ; x(and)v ; x(and)y.
v = np.array([9,10])
w = np.array([11,12])
print(np.dot(v,w))

x = np.array([[1,2],[3,5]])
v = np.array([9,10])
print(np.dot(x,v))

x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
print(np.dot(x,y))

6. #Concatenate x(and)y along row and Concatenate v(and)w along column.
#{Hint:try np.concatenate() or np.vstack() functions.
x = np.array([[1,2],[3,5]])
y = np.array([[5,6],[7,8]])
rConcat = np.hstack((x,y))
print(rConcat)


v = np.array([9,10])
w = np.array([11,12])
cConcat = np.vstack((v,w))
print(cConcat)

#7. Concatenate x(and)v; if you get an error, observe
#and explain why did you get the error?

x = np.array([[1,2],[3,5]])
v = np.array([9,10])
rConcat = np.hstack((x,v))
print(rConcat)
#The concatenation cannot be performed between these two array beacuse the dimension of x-array and v-array does not match

#MATRIX OPERATIONS

#1. Prove A.A−1 = I.
A = np.array([[3, 4],
              [7, 8]])

B = np.array([[5, 3],
              [2, 1]])

A_inv = np.linalg.inv(A)          # Inverse of A
I = np.dot(A, A_inv)              # Multiply A with its inverse
print("A · A⁻¹ =\n", I)
print("Is close to identity?", np.allclose(I, np.eye(2)))


#2. Prove AB ̸= BA.
AB = np.dot(A, B)
BA = np.dot(B, A)

print("AB =\n", AB)
print("BA =\n", BA)
print("Is AB equal to BA?", np.array_equal(AB, BA))


#3.Prove (AB)T = BTAT
AB_T = np.dot(A, B).T           # Transpose of AB
B_T_A_T = np.dot(B.T, A.T)      # Bᵀ · Aᵀ

print("(AB)ᵀ =\n", AB_T)
print("Bᵀ Aᵀ =\n", B_T_A_T)

# Check if they are equal
print("Is (AB)ᵀ equal to Bᵀ Aᵀ?", np.allclose(AB_T, B_T_A_T))

#Solve the following system of Linear equation using Inverse Methods.

#2x − 3y + z = −1
#x − y + 2z = −3
#3x + y − z = 9

import numpy as np

# Coefficient matrix A
A = np.array([[2, -3, 1],
              [1, -1, 2],
              [3, 1, -1]])

# Right-hand side vector B
B = np.array([-1, -3, 9])

# Find inverse of A
A_inv = np.linalg.inv(A)

# Solve for X
X = np.dot(A_inv, B)

print("Solution [x, y, z] =", X)

# solve the above equation using np.linalg.inv function.{Explore more about ”linalg” function
#of Numpy}

A = [[2, -3, 1],
     [1, -1, 2],
     [3, 1, -1]]

B = [-1, -3, 9]

# Coefficient matrix
A = np.array([[2, -3, 1],
              [1, -1, 2],
              [3, 1, -1]])

# Right-hand side
B = np.array([-1, -3, 9])

A_inv = np.linalg.inv(A)
print("Inverse of A:\n", A_inv)

X = np.dot(A_inv, B)   # Matrix multiplication
print("Solution [x, y, z] =", X)